diff --git a/lib/common/messageReader.js b/lib/common/messageReader.js
index a7518d7d9fd6d6dea6669cf8adc99164a95fee65..6f13bc31a4191636279f73b4c1067c751193d374 100644
--- a/lib/common/messageReader.js
+++ b/lib/common/messageReader.js
@@ -129,46 +129,44 @@ class ReadableStreamMessageReader extends AbstractMessageReader {
     onData(data) {
         try {
             this.buffer.append(data);
-            while (true) {
-                if (this.nextMessageLength === -1) {
-                    const headers = this.buffer.tryReadHeaders(true);
-                    if (!headers) {
-                        return;
-                    }
-                    const contentLength = headers.get('content-length');
-                    if (!contentLength) {
-                        this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
-                        return;
-                    }
-                    const length = parseInt(contentLength);
-                    if (isNaN(length)) {
-                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
-                        return;
-                    }
-                    this.nextMessageLength = length;
-                }
-                const body = this.buffer.tryReadBody(this.nextMessageLength);
-                if (body === undefined) {
-                    /** We haven't received the full message yet. */
-                    this.setPartialMessageTimer();
-                    return;
-                }
-                this.clearPartialMessageTimer();
-                this.nextMessageLength = -1;
-                // Make sure that we convert one received message after the
-                // other. Otherwise it could happen that a decoding of a second
-                // smaller message finished before the decoding of a first larger
-                // message and then we would deliver the second message first.
-                this.readSemaphore.lock(async () => {
-                    const bytes = this.options.contentDecoder !== undefined
-                        ? await this.options.contentDecoder.decode(body)
-                        : body;
-                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
-                    this.callback(message);
-                }).catch((error) => {
-                    this.fireError(error);
-                });
+                // if (this.nextMessageLength === -1) {
+                //     const headers = this.buffer.tryReadHeaders(true);
+                //     if (!headers) {
+                //         return;
+                //     }
+                //     const contentLength = headers.get('content-length');
+                //     if (!contentLength) {
+                //         this.fireError(new Error(`Header must provide a Content-Length property.\n${JSON.stringify(Object.fromEntries(headers))}`));
+                //         return;
+                //     }
+                //     const length = parseInt(contentLength);
+                //     if (isNaN(length)) {
+                //         this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
+                //         return;
+                //     }
+                //     this.nextMessageLength = length;
+                // }
+            const body = this.buffer.tryReadBody(this.buffer.numberOfBytes);
+            if (body === undefined) {
+                /** We haven't received the full message yet. */
+                this.setPartialMessageTimer();
+                return;
             }
+            this.clearPartialMessageTimer();
+            this.nextMessageLength = -1;
+            // Make sure that we convert one received message after the
+            // other. Otherwise it could happen that a decoding of a second
+            // smaller message finished before the decoding of a first larger
+            // message and then we would deliver the second message first.
+            this.readSemaphore.lock(async () => {
+                const bytes = this.options.contentDecoder !== undefined
+                    ? await this.options.contentDecoder.decode(body)
+                    : body;
+                const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
+                this.callback(message);
+            }).catch((error) => {
+                this.fireError(error);
+            });
         }
         catch (error) {
             this.fireError(error);
diff --git a/lib/common/messageWriter.js b/lib/common/messageWriter.js
index c6c87208a4d0f777da86bac0891d3bddb8fb28e5..c8a4d32f1186784a6a020edbfc12485db9cdd5d3 100644
--- a/lib/common/messageWriter.js
+++ b/lib/common/messageWriter.js
@@ -96,7 +96,7 @@ class WriteableStreamMessageWriter extends AbstractMessageWriter {
     }
     async doWrite(msg, headers, data) {
         try {
-            await this.writable.write(headers.join(''), 'ascii');
+            // await this.writable.write(headers.join(''), 'ascii');
             return this.writable.write(data);
         }
         catch (error) {
