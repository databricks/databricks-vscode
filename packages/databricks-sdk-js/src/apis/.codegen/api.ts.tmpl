/* eslint-disable @typescript-eslint/naming-convention */

// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

import {ApiClient} from "../../api-client";
import * as model from "./model";
import Time from "../../retries/Time";
import retry from "../../retries/retries";
import {CancellationToken} from "../../types"
import {ApiError, ApiRetriableError} from "../apiError";

{{range $i, $s := .Services }}
export class {{$s.PascalName}}RetriableError extends ApiRetriableError {
	constructor(method: string, message?: string){
		super("{{$s.PascalName}}", method, message)
	}
}
export class {{$s.PascalName}}Error extends ApiError {
	constructor(method: string, message?: string){
		super("{{$s.PascalName}}", method, message)
	}
}

/**
{{$s.Comment "* " 80}}
*/
export class {{$s.PascalName}}Service {
	constructor(readonly client: ApiClient){}

	{{- range $s.Methods}}
	/**
    {{.Comment "    * " 80}}
	*/
    async {{.CamelName}}({{if .Request}}request:  model.{{.Request.PascalName}},{{end}}
        cancellationToken?: CancellationToken
	): Promise<model.{{if .Response}}{{.Response.PascalName}}{{else}}{{.EmptyResponseName.PascalName}}{{end}}> {
			const path = {{if .PathParts}}`{{range .PathParts}}{{.Prefix}}{{if .Field}}${request.{{.Field.SnakeName}}}{{end}}{{end}}`{{else}}"{{.Path}}"{{end}}
			return (await this.client.request(
				path,
				"{{.Verb}}",
				{{if .Request -}}request{{else}}undefined{{end}}, 
				cancellationToken
			) as model.{{if .Response}}{{.Response.PascalName}}{{else}}{{.EmptyResponseName.PascalName}}{{end}})
		}

	{{if .Wait}}
	/**
	* {{.CamelName}} and wait to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state
	* {{if .Wait.Failure}} or fail on reaching {{range $i, $e := .Wait.Failure}}{{if $i}} or {{end}}{{.Content}}{{end}} state{{end}}
	*/
	async {{.CamelName}}AndWait({request, timeout, cancellationToken, onProgress= async (newPollResponse) => {}}:{
		{{if .Request}}request: model.{{.Request.PascalName}}{{end}}, 
		timeout?: Time,
		cancellationToken?: CancellationToken,
		onProgress?: (newPollResponse: model.{{if .Wait.Poll.Response}}{{.Wait.Poll.Response.PascalName}}{{else}}{{.Wait.Poll.EmptyResponseName.PascalName}}{{end}}) => Promise<void>
		}): Promise<model.{{if .Wait.Poll.Response}}{{.Wait.Poll.Response.PascalName}}{{else}}{{.Wait.Poll.EmptyResponseName.PascalName}}{{end}}> {
		const response = await this.{{.CamelName}}(request);

		return await retry<model.{{if .Wait.Poll.Response}}{{.Wait.Poll.Response.PascalName}}{{else}}{{.Wait.Poll.EmptyResponseName.PascalName}}{{end}}>({
			timeout: timeout,
			fn: async () => {
				const pollResponse = await this.{{.Wait.Poll.CamelName}}({ {{$e := .}}{{range .Wait.Binding}}
					{{.Bind.SnakeName}}: {{if $e.Wait.ForceBindRequest}}request{{else if $e.Response}}response{{else}}request{{end}}.{{.Bind.SnakeName}}{{end}}!
				}, cancellationToken)
				if(cancellationToken?.isCancellationRequested) {
					throw new {{$s.PascalName}}Error("{{.CamelName}}AndWait", "cancelled");
				}
				await onProgress(pollResponse);
				const status = pollResponse{{range $i, $e := .Wait.StatusPath}}{{if $i}}!{{end}}.{{$e.SnakeName}}{{end}}
				const statusMessage = pollResponse{{range $i, $e := .Wait.MessagePath}}{{if $i}}!{{end}}.{{$e.SnakeName}}{{end}}
				switch(status) {
					{{range $i, $e := .Wait.Success}}{{if $i}} {{end}}case '{{$e.Content}}':{{end}}{
						return pollResponse
					}
					{{if .Wait.Failure}}{{range $i, $e := .Wait.Failure}}{{if $i}} {{end}}case '{{$e.Content}}':{{end}}{
						throw new {{$s.PascalName}}Error("{{.CamelName}}AndWait", `failed to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state, got ${status}: ${statusMessage}`)
					}
					{{end}}default:{
						throw new {{$s.PascalName}}RetriableError("{{.CamelName}}AndWait", `failed to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state, got ${status}: ${statusMessage}`)
					}
				}
			}
		});
	}
	{{end}}
	{{end}}
}
{{end}}
