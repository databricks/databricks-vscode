/* eslint-disable @typescript-eslint/naming-convention */

// Code generated from OpenAPI specs by Databricks SDK Generator. DO NOT EDIT.

import {ApiClient} from "../../api-client";
import * as model from "./model";
import Time from "../../retries/Time";
import retry, {RetriableError} from "../../retries/retries";

{{- range $i, $s := .Services }}
export class {{$s.PascalName}}RetriableError extends RetriableError {}
export class {{$s.PascalName}}Error extends Error {}

/**
{{$s.Comment "* " 80}}
*/
export class {{$s.PascalName}}Service {
	constructor(readonly client: ApiClient){}

	{{- range $s.Methods}}
	/**
    {{.Comment "    * " 80}}
	*/
    async {{.CamelName}}({{if .Request}}request:  model.{{.Request.PascalName}}{{end}}): Promise<model.{{if .Response}}{{.Response.PascalName}}{{else}}{{.EmptyResponseName.PascalName}}{{end}}> {
			const path = {{if .PathParts}}`{{range .PathParts}}{{.Prefix}}{{if .Field}}${request.{{.Field.SnakeName}}}{{end}}{{end}}`{{else}}"{{.Path}}"{{end}}
			return await this.client.request(
				path,
				"{{.Verb}}",
				{{if .Request}}request{{end}}
			) as model.{{if .Response}}{{.Response.PascalName}}{{else}}{{.EmptyResponseName.PascalName}}{{end}}
		}

	{{if .Wait}}
	/**
	* {{.CamelName}} and wait to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state
	* {{if .Wait.Failure}} or fail on reaching {{range $i, $e := .Wait.Failure}}{{if $i}} or {{end}}{{.Content}}{{end}} state{{end}}
	*/
	async {{.CamelName}}AndWait({{if .Request}}request: model.{{.Request.PascalName}}{{end}}, timeout?: Time): Promise<model.{{if .Wait.Poll.Response}}{{.Wait.Poll.Response.PascalName}}{{else}}{{.Wait.Poll.EmptyResponseName.PascalName}}{{end}}> {
		const response = await this.{{.CamelName}}(request);

		return await retry<model.{{if .Wait.Poll.Response}}{{.Wait.Poll.Response.PascalName}}{{else}}{{.Wait.Poll.EmptyResponseName.PascalName}}{{end}}>({
			timeout: timeout,
			fn: async () => {
				const pollResponse = await this.{{.Wait.Poll.CamelName}}({
					{{.Wait.Bind.SnakeName}}: {{if .Wait.ForceBindRequest}}request{{else if .Response}}response{{else}}request{{end}}.{{.Wait.Bind.SnakeName}}!
				})
				const status = pollResponse{{range $i, $e := .Wait.StatusPath}}{{if $i}}!{{end}}.{{$e.SnakeName}}{{end}}
				const statusMessage = pollResponse{{range $i, $e := .Wait.MessagePath}}{{if $i}}!{{end}}.{{$e.SnakeName}}{{end}}
				switch(status) {
					{{range $i, $e := .Wait.Success}}{{if $i}} {{end}}case '{{$e.Content}}':{{end}}{
						return pollResponse
					}
					{{if .Wait.Failure}}{{range $i, $e := .Wait.Failure}}{{if $i}} {{end}}case '{{$e.Content}}':{{end}}{
						throw new {{$s.PascalName}}Error(`failed to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state, got ${status}: ${statusMessage}`)
					}
					{{end}}default:{
						throw new {{$s.PascalName}}RetriableError(`failed to reach {{range $i, $e := .Wait.Success}}{{if $i}} or {{end}}{{.Content}}{{end}} state, got ${status}: ${statusMessage}`)
					}
				}
			}
		});
	}
	{{end}}
	{{end}}
}
{{end}}
